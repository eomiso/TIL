(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{353:function(t,a,s){"use strict";s.r(a);var r=s(20),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"cs224n-10강-정리"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cs224n-10강-정리"}},[t._v("#")]),t._v(" cs224n 10강 정리")]),t._v(" "),s("h2",{attrs:{id:"개요"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#개요"}},[t._v("#")]),t._v(" 개요")]),t._v(" "),s("ul",[s("li",[t._v("Machine Comprehension")]),t._v(" "),s("li",[t._v("Extrative QA")]),t._v(" "),s("li",[t._v("SQUAD 1.0 vs SQUAD 2.0")]),t._v(" "),s("li",[t._v("F1 score")]),t._v(" "),s("li",[t._v("Stanford attentive Reader, BiDAF, FusionNet")])]),t._v(" "),s("h2",{attrs:{id:"machine-comprehension"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#machine-comprehension"}},[t._v("#")]),t._v(" Machine Comprehension")]),t._v(" "),s("p",[t._v("Information retrieval 관련 되는 도큐먼트들을 찾아서 보여주는 방법으로는 한계가 있다.\n그래서 Reading Comprehension 방법을 추가해서 해결한다. 이 방법은 최초의 NLP에서 시도했던 problem 중 하나다(1977, Lynette Hirschman 1999)")]),t._v(" "),s("p",[t._v("Burges (2013)가 Machin Comprehension이 사실 머신러닝의 주요한 문제임을 지적하면서 그 개념을 제시했다.")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("Definition")]),t._v(" "),s("p",[t._v("A machine comrehends a passage of text if, for any question regarding that text that can be answered correctly by a majority of native speakers, that mahcnie can provide a stirng which those speakers would agree both answers that question, and does not contain information irrelevatn to that question.")])]),t._v(" "),s("h2",{attrs:{id:"extrative-qa"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#extrative-qa"}},[t._v("#")]),t._v(" Extrative QA")]),t._v(" "),s("p",[t._v("Often referred to as reading comprehension. Its data is formed from triple.\n즉 질문이 있으면 주어진 도큐먼트로부터 정답을 추출하여 답을 출력하는 task를 의미하고 아래의 SQUAD가 이러한 task에 적합한 데이터를 모아두고 있다.\nNo yes or no questions, just questions that could be anwsered in subsequent string or span.")]),t._v(" "),s("h2",{attrs:{id:"squad"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#squad"}},[t._v("#")]),t._v(" SQUAD")]),t._v(" "),s("p",[t._v("3 사람이 답한 바를 정답으로 한다.\n참고로 BERT(ensemble) from Google AI Language가가장 정답률이 높다."),s("br"),t._v("\nSQUAD version 2.0 는 1.0에는 모든 정답이 paragraph에 있다는 단점이 있었다. 그래서 2.0에는 No answer가 정답인 데이터가 들어갔다."),s("br"),t._v("\n오답을 통해서 시스템이 어떻게 돌아가는 지를 확인할 수도 있다. 1234 정답 확인")]),t._v(" "),s("p",[t._v("그런데 이런 방식(paragraph를 보고 그에 기반한 질문이 작성되었다는 점)은 사실 task를 unnaturaly easy 하게 만든다.\nNLI 같은 정보를 사용하지 않는 데이터셋이다(he, it, she)")]),t._v(" "),s("h2",{attrs:{id:"f1-score"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#f1-score"}},[t._v("#")]),t._v(" F1 score")]),t._v(" "),s("p",[t._v("Precision = "),s("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[s("mjx-math",{staticClass:" MJX-TEX"},[s("mjx-mfrac",[s("mjx-frac",[s("mjx-num",[s("mjx-nstrut"),s("mjx-mrow",{attrs:{size:"s"}},[s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"T"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"P"}})],1)],1)],1),s("mjx-dbox",[s("mjx-dtable",[s("mjx-line"),s("mjx-row",[s("mjx-den",[s("mjx-dstrut"),s("mjx-mrow",{attrs:{size:"s"}},[s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"T"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"P"}})],1),s("mjx-mo",{staticClass:"mjx-n"},[s("mjx-c",{attrs:{c:"+"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"F"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"P"}})],1)],1)],1)],1)],1)],1)],1)],1)],1)],1),t._v("\nRecall = "),s("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[s("mjx-math",{staticClass:" MJX-TEX"},[s("mjx-mfrac",[s("mjx-frac",[s("mjx-num",[s("mjx-nstrut"),s("mjx-mrow",{attrs:{size:"s"}},[s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"T"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"P"}})],1)],1)],1),s("mjx-dbox",[s("mjx-dtable",[s("mjx-line"),s("mjx-row",[s("mjx-den",[s("mjx-dstrut"),s("mjx-mrow",{attrs:{size:"s"}},[s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"T"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"P"}})],1),s("mjx-mo",{staticClass:"mjx-n"},[s("mjx-c",{attrs:{c:"+"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"F"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"N"}})],1)],1)],1)],1)],1)],1)],1)],1)],1)],1),t._v("\nF1 = "),s("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[s("mjx-math",{staticClass:" MJX-TEX"},[s("mjx-mfrac",[s("mjx-frac",[s("mjx-num",[s("mjx-nstrut"),s("mjx-mrow",{attrs:{size:"s"}},[s("mjx-mn",{staticClass:"mjx-n"},[s("mjx-c",{attrs:{c:"2"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"P"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"R"}})],1)],1)],1),s("mjx-dbox",[s("mjx-dtable",[s("mjx-line"),s("mjx-row",[s("mjx-den",[s("mjx-dstrut"),s("mjx-mrow",{attrs:{size:"s"}},[s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"P"}})],1),s("mjx-mo",{staticClass:"mjx-n"},[s("mjx-c",{attrs:{c:"+"}})],1),s("mjx-mi",{staticClass:"mjx-i"},[s("mjx-c",{attrs:{c:"R"}})],1)],1)],1)],1)],1)],1)],1)],1)],1)],1),t._v(" -> a very conservative average")],1),t._v(" "),s("p",[t._v("F1 is more reliable and taken as primary than Exact Match.")]),t._v(" "),s("h2",{attrs:{id:"stanford-attentive-reader-bidaf-fusionnet"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stanford-attentive-reader-bidaf-fusionnet"}},[t._v("#")]),t._v(" Stanford attentive Reader, BiDAF, FusionNet")]),t._v(" "),s("p",[t._v("상대적으로 간단한 예시를 보여준다.")]),t._v(" "),s("p",[s("img",{attrs:{src:"/TIL/ML/attentiveplus.png",alt:""}}),t._v(" "),s("img",{attrs:{src:"/TIL/ML/attentiveplus2.png",alt:""}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/TIL/ML/Bidaf.png",alt:""}})])])}),[],!1,null,null,null);a.default=e.exports}}]);